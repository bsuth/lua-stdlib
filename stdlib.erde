-- -----------------------------------------------------------------------------
-- Libraries
--
-- Forward declared to be accessible anywhere.
-- -----------------------------------------------------------------------------

local _native_coroutine = coroutine
module coroutine = setmetatable({}, { __index = _native_coroutine })

local _native_debug = debug
module debug = setmetatable({}, { __index = _native_debug })

local _native_io = io
module io = setmetatable({}, { __index = _native_io })

local _native_math = math
module math = setmetatable({}, { __index = _native_math })

local _native_os = os
module os = setmetatable({}, { __index = _native_os })

local _native_package = package
module package = setmetatable({}, { __index = _native_package })

local _native_string = string
module string = setmetatable({}, { __index = _native_string })

local _native_table = table
module table = setmetatable({}, { __index = _native_table })

-- -----------------------------------------------------------------------------
-- Load / Unload
-- -----------------------------------------------------------------------------

module function load() {
  for key, value in pairs(_MODULE) {
    local value_type = type(value)

    if value_type == 'function' {
      if key != 'load' && key != 'unload' {
        _G[key] = value
      }
    } elseif value_type == 'table' {
      local library = _G[key]

      if type(library) == 'table' {
        for subkey, subvalue in pairs(value) {
          library[subkey] = subvalue
        }
      }
    }
  }
}

module function unload() {
  for key, value in pairs(_MODULE) {
    local value_type = type(value)

    if value_type == 'function' {
      if _G[key] == value { -- only remove values we injected
        _G[key] = nil
      }
    } elseif value_type == 'table' {
      local library = _G[key]

      if type(library) == 'table' {
        for subkey, subvalue in pairs(value) {
          if library[subkey] == subvalue { -- only remove values we injected
            library[subkey] = nil
          }
        }
      }
    }
  }
}

-- -----------------------------------------------------------------------------
-- Globals
-- -----------------------------------------------------------------------------

local function _kpairs_iter(a, i) {
  local key, value = i, nil

  repeat {
    key, value = next(a, key)
  } until type(key) != 'number'

  return key, value
}

module function kpairs(t) {
  return _kpairs_iter, t, nil
}

-- -----------------------------------------------------------------------------
-- Coroutine
-- -----------------------------------------------------------------------------

-- EMPTY

-- -----------------------------------------------------------------------------
-- Debug
-- -----------------------------------------------------------------------------

-- EMPTY

-- -----------------------------------------------------------------------------
-- IO
-- -----------------------------------------------------------------------------

-- EMPTY

-- -----------------------------------------------------------------------------
-- Math
-- -----------------------------------------------------------------------------

function math.clamp(x, min, max) {
  return math.min(math.max(x, min), max)
}

function math.round(x) {
  if x < 0 {
    return math.ceil(x - 0.5)
  } else {
    return math.floor(x + 0.5)
  }
}

function math.sign(x) {
  if x < 0 {
    return -1
  } elseif x > 0 {
    return 1
  } else {
    return 0
  }
}

-- -----------------------------------------------------------------------------
-- OS
-- -----------------------------------------------------------------------------

-- EMPTY

-- -----------------------------------------------------------------------------
-- Package
-- -----------------------------------------------------------------------------

function package.cinsert(...) {
  local templates = package.split(package.cpath)
  table.insert(templates, ...)
  _native_package.cpath = package.concat(templates)
}

function package.concat(templates, i, j) {
  local template_separator = string.split(package.config, '\n')[2]
  return table.concat(templates, template_separator, i, j)
}

function package.cremove(position) {
  local templates = package.split(package.cpath)
  local removed = table.remove(templates, position)
  _native_package.cpath = package.concat(templates)
  return removed
}

function package.insert(...) {
  local templates = package.split(package.path)
  table.insert(templates, ...)
  _native_package.path = package.concat(templates)
}

function package.remove(position) {
  local templates = package.split(package.path)
  local removed = table.remove(templates, position)
  _native_package.path = package.concat(templates)
  return removed
}

function package.split(path) {
  local template_separator = string.split(package.config, '\n')[2]
  return string.split(path, template_separator)
}

-- -----------------------------------------------------------------------------
-- String
-- -----------------------------------------------------------------------------

function string.escape(s) {
  local result = {}

  for _, part in ipairs(string.split(s, '%%%%')) {
    part = part:gsub('^([().*?[^$+-])', '%%%1')
    part = part:gsub('([^%%])([().*?[^$+-])', '%1%%%2')
    part = part:gsub('%%([^%%().*?[^$+-])', '%%%%%1')
    part = part:gsub('%%$', '%%%%')
    table.insert(result, part)
  }

  return table.concat(result, '%%')
}

function string.lpad(s, length, padding = ' ') {
  return padding:rep(math.ceil((length - #s) / #padding)) .. s
}

function string.ltrim(s, pattern = '%s+') {
  -- Wrap in parentheses to only get first return
  return (s:gsub("^{pattern}", ''))
}

function string.pad(s, length, padding = ' ') {
  local num_pads = math.ceil(((length - #s) / #padding) / 2)
  return padding:rep(num_pads) .. s .. padding:rep(num_pads)
}

function string.rpad(s, length, padding = ' ') {
  return s .. padding:rep(math.ceil((length - #s) / #padding))
}

function string.rtrim(s, pattern = '%s+') {
  -- Wrap in parentheses to only get first return
  return (s:gsub("{pattern}$", ''))
}

function string.split(s, separator = '%s+') {
  local result = {}
  local i, j = s:find(separator)

  while i != nil {
    table.insert(result, s:sub(1, i - 1))
    s = s:sub(j + 1) || ''
    i, j = s:find(separator)
  }

  table.insert(result, s)
  return result
}

function string.trim(s, pattern = '%s+') {
  return string.ltrim(string.rtrim(s, pattern), pattern)
}

-- -----------------------------------------------------------------------------
-- Table
-- -----------------------------------------------------------------------------

-- Polyfill `table.pack` and `table.unpack`
if _VERSION == 'Lua 5.1' {
  table.pack = (...) -> ({ n =  select('#', ...), ... })
  table.unpack = unpack
}

function table.collect(t, iterator) {
  local result = {}

  for key, value in iterator(t) {
    if value == nil {
      table.insert(result, key)
    } else {
      result[key] = value
    }
  }

  return result
}

function table.deepcopy(t) {
  local result = {}

  for key, value in pairs(t) {
    if type(value) == 'table' {
      result[key] = table.deepcopy(value)
    } else {
      result[key] = value
    }
  }

  return result
}

function table.empty(t) {
  return next(t) == nil
}

function table.filter(t, callback) {
  local result = {}

  for key, value in pairs(t) {
    if callback(value, key) {
      if type(key) == 'number' {
        table.insert(result, value)
      } else {
        result[key] = value
      }
    }
  }

  return result
}

function table.find(t, callback) {
  if type(callback) == 'function' {
    for key, value in pairs(t) {
      if callback(value, key) {
        return value, key
      }
    }
  } else {
    for key, value in pairs(t) {
      if value == callback {
        return value, key
      }
    }
  }
}

function table.keys(t) {
  local result = {}

  for key, value in pairs(t) {
    table.insert(result, key)
  }

  return result
}

function table.map(t, callback) {
  local result = {}

  for key, value in pairs(t) {
    local newValue, newKey = callback(value, key)

    if newKey != nil {
      result[newKey] = newValue
    } elseif type(key) == 'number' {
      table.insert(result, newValue)
    } else {
      result[key] = newValue
    }
  }

  return result
}

function table.merge(t, ...) {
  for _, _t in pairs({ ... }) {
    for key, value in pairs(_t) {
      if type(key) == 'number' {
        table.insert(t, value)
      } else {
        t[key] = value
      }
    }
  }
}

function table.reduce(t, initial, callback) {
  local result = initial

  for key, value in pairs(t) {
    result = callback(result, value, key)
  }

  return result
}

function table.reverse(t) {
  local len = #t

  for i = 1, math.floor(len / 2) {
    t[i], t[len - i + 1] = t[len - i + 1], t[i]
  }
}

function table.shallowcopy(t) {
  local result = {}

  for key, value in pairs(t) {
    result[key] = value
  }

  return result
}

function table.slice(t, i = 1, j = #t) {
  local result, len = {}, #t

  if i < 0 { i = i + len + 1 }
  if j < 0 { j = j + len + 1 }

  for i = math.max(i, 0), math.min(j, len) {
    table.insert(result, t[i])
  }

  return result
}

function table.values(t) {
  local result = {}

  for key, value in pairs(t) {
    table.insert(result, value)
  }

  return result
}
