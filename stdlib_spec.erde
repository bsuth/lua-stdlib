local stdlib = require('stdlib')

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function any_sort(a, b) {
  if type(a) == type(b) {
    return a < b
  } else {
    return type(a) < type(b)
  }
}

-- -----------------------------------------------------------------------------
-- Load / Unload
-- -----------------------------------------------------------------------------

spec('load / unload', () -> {
  local function assert_loaded(library_name) {
    for key in pairs(stdlib[library_name]) {
      assert.are.equal(_G[library_name][key], stdlib[library_name][key])
    }
  }

  local function assert_unloaded(library_name) {
    for key in pairs(stdlib[library_name]) {
      assert.is_nil(_G[library_name][key])
    }
  }

  assert_unloaded('coroutine')
  assert_unloaded('debug')
  assert_unloaded('io')
  assert_unloaded('math')
  assert_unloaded('os')
  assert_unloaded('package')
  assert_unloaded('string')
  assert_unloaded('table')

  stdlib.load()

  -- make sure `load` and `unload` themselves are not injected
  assert.are_not.equal(_G.load, stdlib.load)
  assert.are_not.equal(_G.unload, stdlib.unload)

  -- globals
  assert.are.equal(_G.kpairs, stdlib.kpairs)

  -- libraries
  assert_loaded('coroutine')
  assert_loaded('debug')
  assert_loaded('io')
  assert_loaded('math')
  assert_loaded('os')
  assert_loaded('package')
  assert_loaded('string')
  assert_loaded('table')

  stdlib.unload()

  assert_unloaded('coroutine')
  assert_unloaded('debug')
  assert_unloaded('io')
  assert_unloaded('math')
  assert_unloaded('os')
  assert_unloaded('package')
  assert_unloaded('string')
  assert_unloaded('table')
})

-- -----------------------------------------------------------------------------
-- Globals
-- -----------------------------------------------------------------------------

spec('kpairs', () -> {
  local function assert_kpairs(expected, t) {
    local result = {}

    for key, value in stdlib.kpairs(t) {
      result[key] = value
    }

    assert.are.same(expected, result)
  }

  assert_kpairs({}, {})
  assert_kpairs({}, { 'hello', 'world' })
  assert_kpairs(
    { mykey = 'hello', myotherkey = 'world' },
    { mykey = 'hello', myotherkey = 'world' },
  )
  assert_kpairs(
    { mykey = 'hello', myotherkey = 'world' },
    { mykey = 'hello', myotherkey = 'world', 'hello', 'world' },
  )
})

-- -----------------------------------------------------------------------------
-- Coroutine
-- -----------------------------------------------------------------------------

spec('coroutine', () -> {
  assert.is_table(stdlib.coroutine)
  for key in pairs(coroutine) {
    assert.are.equal(coroutine[key], stdlib.coroutine[key])
  }
})

-- -----------------------------------------------------------------------------
-- Debug
-- -----------------------------------------------------------------------------

spec('debug', () -> {
  assert.is_table(stdlib.debug)
  for key in pairs(debug) {
    assert.are.equal(debug[key], stdlib.debug[key])
  }
})

-- -----------------------------------------------------------------------------
-- IO
-- -----------------------------------------------------------------------------

spec('io', () -> {
  assert.is_table(stdlib.io)
  for key in pairs(io) {
    assert.are.equal(io[key], stdlib.io[key])
  }
})

-- -----------------------------------------------------------------------------
-- Math
-- -----------------------------------------------------------------------------

spec('math', () -> {
  assert.is_table(stdlib.math)
  for key in pairs(math) {
    assert.are.equal(math[key], stdlib.math[key])
  }
})

spec('math.clamp', () -> {
  assert.are.equal(0, stdlib.math.clamp(0, 0, 1))
  assert.are.equal(0.5, stdlib.math.clamp(0.5, 0, 1))
  assert.are.equal(0, stdlib.math.clamp(-0.5, 0, 1))
  assert.are.equal(1, stdlib.math.clamp(1.5, 0, 1))
})

spec('math.product', () -> {
  assert.are.equal(1, stdlib.math.product())
  assert.are.equal(0, stdlib.math.product(0))
  assert.are.equal(1, stdlib.math.product(1))
  assert.are.equal(24, stdlib.math.product(1, 2, 3, 4))
  assert.are.equal(-6, stdlib.math.product(1, -2, 3))
})

spec('math.round', () -> {
  assert.are.equal(-1, stdlib.math.round(-1))
  assert.are.equal(-1, stdlib.math.round(-0.9))
  assert.are.equal(-1, stdlib.math.round(-0.51))
  assert.are.equal(-1, stdlib.math.round(-0.5))
  assert.are.equal(0, stdlib.math.round(-0.49))
  assert.are.equal(0, stdlib.math.round(-0.1))
  assert.are.equal(0, stdlib.math.round(0))
  assert.are.equal(0, stdlib.math.round(0.1))
  assert.are.equal(0, stdlib.math.round(0.49))
  assert.are.equal(1, stdlib.math.round(0.5))
  assert.are.equal(1, stdlib.math.round(0.51))
  assert.are.equal(1, stdlib.math.round(0.9))
  assert.are.equal(1, stdlib.math.round(1))
})

spec('math.sign', () -> {
  assert.are.equal(-1, stdlib.math.sign(-3))
  assert.are.equal(-1, stdlib.math.sign(-1))
  assert.are.equal(1, stdlib.math.sign(0))
  assert.are.equal(1, stdlib.math.sign(1))
  assert.are.equal(1, stdlib.math.sign(4))
})

spec('math.sum', () -> {
  assert.are.equal(0, stdlib.math.sum())
  assert.are.equal(0, stdlib.math.sum(0))
  assert.are.equal(1, stdlib.math.sum(1))
  assert.are.equal(10, stdlib.math.sum(1, 2, 3, 4))
  assert.are.equal(-2, stdlib.math.sum(1, -2, 3, -4))
})

-- -----------------------------------------------------------------------------
-- OS
-- -----------------------------------------------------------------------------

spec('os', () -> {
  assert.is_table(stdlib.os)
  for key in pairs(os) {
    assert.are.equal(os[key], stdlib.os[key])
  }
})

-- -----------------------------------------------------------------------------
-- Package
-- -----------------------------------------------------------------------------

spec('package', () -> {
  assert.is_table(stdlib.package)
  for key in pairs(package) {
    assert.are.equal(package[key], stdlib.package[key])
  }
})

-- -----------------------------------------------------------------------------
-- String
-- -----------------------------------------------------------------------------

spec('string', () -> {
  assert.is_table(stdlib.string)
  for key in pairs(string) {
    assert.are.equal(string[key], stdlib.string[key])
  }
})

spec('string.escape', () -> {
  assert.are.equal('a', stdlib.string.escape('a'))
  assert.are.equal('1', stdlib.string.escape('1'))
  assert.are.equal(',', stdlib.string.escape(','))

  assert.are.equal('%%', stdlib.string.escape('%'))
  assert.are.equal('%(', stdlib.string.escape('('))
  assert.are.equal('%)', stdlib.string.escape(')'))
  assert.are.equal('%.', stdlib.string.escape('.'))
  assert.are.equal('%*', stdlib.string.escape('*'))
  assert.are.equal('%?', stdlib.string.escape('?'))
  assert.are.equal('%[', stdlib.string.escape('['))
  assert.are.equal('%^', stdlib.string.escape('^'))
  assert.are.equal('%$', stdlib.string.escape('$'))
  assert.are.equal('%+', stdlib.string.escape('+'))
  assert.are.equal('%-', stdlib.string.escape('-'))

  assert.are.equal('a%%', stdlib.string.escape('a%'))
  assert.are.equal('a%(', stdlib.string.escape('a('))
  assert.are.equal('a%)', stdlib.string.escape('a)'))
  assert.are.equal('a%.', stdlib.string.escape('a.'))
  assert.are.equal('a%*', stdlib.string.escape('a*'))
  assert.are.equal('a%?', stdlib.string.escape('a?'))
  assert.are.equal('a%[', stdlib.string.escape('a['))
  assert.are.equal('a%^', stdlib.string.escape('a^'))
  assert.are.equal('a%$', stdlib.string.escape('a$'))
  assert.are.equal('a%+', stdlib.string.escape('a+'))
  assert.are.equal('a%-', stdlib.string.escape('a-'))

  assert.are.equal('%%', stdlib.string.escape('%%'))
  assert.are.equal('%(', stdlib.string.escape('%('))
  assert.are.equal('%)', stdlib.string.escape('%)'))
  assert.are.equal('%.', stdlib.string.escape('%.'))
  assert.are.equal('%*', stdlib.string.escape('%*'))
  assert.are.equal('%?', stdlib.string.escape('%?'))
  assert.are.equal('%[', stdlib.string.escape('%['))
  assert.are.equal('%^', stdlib.string.escape('%^'))
  assert.are.equal('%$', stdlib.string.escape('%$'))
  assert.are.equal('%+', stdlib.string.escape('%+'))
  assert.are.equal('%-', stdlib.string.escape('%-'))

  assert.are.equal('%%%(', stdlib.string.escape('%%('))
  assert.are.equal('%(%%', stdlib.string.escape('(%%'))
  assert.are.equal('%%%%', stdlib.string.escape('%%%%'))
  assert.are.equal('%%%(%%', stdlib.string.escape('%%(%%'))
})

spec('string.split', () -> {
  assert.are.same({ 'a', 'b', 'c' }, stdlib.string.split('a b c'))
  assert.are.same({ 'a', 'b', 'c' }, stdlib.string.split('a  b \tc'))

  assert.are.same({ '', 'a' }, stdlib.string.split(' a'))
  assert.are.same({ 'a', '' }, stdlib.string.split('a '))
  assert.are.same({ '', 'a', '' }, stdlib.string.split(' a '))

  assert.are.same({ ' ', ' ' }, stdlib.string.split(' a ', '%a+'))
  assert.are.same({ 'hello', 'world' }, stdlib.string.split('hello11world', '%d+'))
})

spec('string.trim', () -> {
  assert.are.equal('hello', stdlib.string.trim('hello'))

  assert.are.equal('hello', stdlib.string.trim('hello '))
  assert.are.equal('hello', stdlib.string.trim(' hello'))
  assert.are.equal('hello', stdlib.string.trim(' hello '))
  assert.are.equal('hello', stdlib.string.trim('hello  '))
  assert.are.equal('hello', stdlib.string.trim('  hello'))
  assert.are.equal('hello', stdlib.string.trim('  hello  '))

  assert.are.equal('hello', stdlib.string.trim('\thello'))
  assert.are.equal('hello', stdlib.string.trim('hello\t'))
  assert.are.equal('hello', stdlib.string.trim('\thello\t'))
  assert.are.equal('hello', stdlib.string.trim('\t\thello'))
  assert.are.equal('hello', stdlib.string.trim('hello\t\t'))
  assert.are.equal('hello', stdlib.string.trim('\t\thello\t\t'))

  assert.are.equal('hello', stdlib.string.trim('\nhello'))
  assert.are.equal('hello', stdlib.string.trim('hello\n'))
  assert.are.equal('hello', stdlib.string.trim('\nhello\n'))
  assert.are.equal('hello', stdlib.string.trim('\n\nhello'))
  assert.are.equal('hello', stdlib.string.trim('hello\n\n'))
  assert.are.equal('hello', stdlib.string.trim('\n\nhello\n\n'))

  assert.are.equal('hello', stdlib.string.trim('\n\t hello\t \n'))
  assert.are.equal('hello', stdlib.string.trim('xxhelloxx', 'x+'))
})

-- -----------------------------------------------------------------------------
-- Table
-- -----------------------------------------------------------------------------

spec('table', () -> {
  assert.is_table(stdlib.table)
  for key in pairs(table) {
    assert.are.equal(table[key], stdlib.table[key])
  }
})

spec('table.assign', () -> {
  local function assert_assign(expected, target, ...) {
    stdlib.table.assign(target, ...)
    assert.are.same(expected, target)
  }

  assert_assign({}, {})
  assert_assign({ a = 1 }, {}, { a = 1 })
  assert_assign({ a = 2 }, {}, { a = 1 }, { a = 2 })
  assert_assign({ a = 1, b = 2 }, {}, { a = 1 }, { b = 2 })
  assert_assign({ a = 2 }, { a = 1 }, { a = 2 })
  assert_assign({ a = 1, b = 2 }, { a = 1 }, { b = 2 })
  assert_assign({ a = 1, b = 2, c = 3 }, { a = 1, c = 3 }, { b = 2 })
  assert_assign({ 1 }, { 1 })
  assert_assign({}, {}, { 1 })
})

spec('table.clone', () -> {
  local function assert_clone(t, clone = stdlib.table.clone(t)) {
    assert.are_not.equal(t, clone)
    assert.are.same(t, clone)

    for key, value in pairs(t) {
      if type(value) == 'stdlib.table' {
        assert_clone(value, clone[key])
      }
    }
  }

  assert_clone({})
  assert_clone({ 1, 2, 3 })
  assert_clone({ a = 1, b = 2, c = 3 })
  assert_clone({ a = 1, 'hello' })
  assert_clone({ a = 1, b = 2, 'hello', 'world' })
  assert_clone({ { 'hello' } })
  assert_clone({ a = { 'hello' } })
  assert_clone({ a = { 'hello' }, { 'world' } })
})

spec('table.copy', () -> {
  local function assert_copy(t) {
    local copy = stdlib.table.copy(t)

    assert.are_not.equal(t, copy)
    assert.are.same(t, copy)

    for key, value in pairs(t) {
      assert.are.equal(value, copy[key])
    }
  }

  assert_copy({})
  assert_copy({ 1, 2, 3 })
  assert_copy({ a = 1, b = 2, c = 3 })
  assert_copy({ a = 1, 'hello' })
  assert_copy({ a = 1, b = 2, 'hello', 'world' })
  assert_copy({ { 'hello' } })
  assert_copy({ a = { 'hello' } })
  assert_copy({ a = { 'hello' }, { 'world' } })
})

spec('table.default', () -> {
  local function assert_default(expected, target, ...) {
    stdlib.table.default(target, ...)
    assert.are.same(expected, target)
  }

  assert_default({}, {})
  assert_default({ a = 1 }, {}, { a = 1 })
  assert_default({ a = 1 }, {}, { a = 1 }, { a = 2 })
  assert_default({ a = 1, b = 2 }, {}, { a = 1 }, { b = 2 })
  assert_default({ a = 1 }, { a = 1 }, { a = 2 })
  assert_default({ a = 1, b = 2 }, { a = 1 }, { b = 2 })
  assert_default({ a = 1, b = 2, c = 3 }, { a = 1, c = 3 }, { b = 2 })
  assert_default({ 1 }, { 1 })
  assert_default({}, {}, { 1 })
})

spec('table.filter', () -> {
  assert.are.same({}, stdlib.table.filter({}, () -> false))
  assert.are.same({}, stdlib.table.filter({}, () -> true))
  assert.are.same({}, stdlib.table.filter({ 1, 2, 3 }, () -> false))
  assert.are.same({ 1, 2, 3 }, stdlib.table.filter({ 1, 2, 3 }, () -> true))
  assert.are.same({}, stdlib.table.filter({ a = 1, b = 2 }, () -> false))
  assert.are.same({ a = 1, b = 2 }, stdlib.table.filter({ a = 1, b = 2 }, () -> true))
  assert.are.same({ 1, 2 }, stdlib.table.filter({ 1, 2, 3 }, value -> value < 3))
  assert.are.same({ 3 }, stdlib.table.filter({ 1, 2, 3 }, value -> value > 2))
  assert.are.same({ a = 1 }, stdlib.table.filter({ a = 1, b = 2 }, value -> value < 2))
  assert.are.same({ b = 2 }, stdlib.table.filter({ a = 1, b = 2 }, value -> value > 1))
  assert.are.same({ a = 1 }, stdlib.table.filter({ a = 1, b = 2 }, (_, key) -> key == 'a'))
})

spec('table.find', () -> {
  local function assert_find(expected_key, t, callback) {
    local value, key = stdlib.table.find(t, callback)
    assert.are.equal(expected_key, key)
    assert.are.equal(t[expected_key], value)
  }

  assert_find(1, { 'a', 'b', 'c' }, 'a')
  assert_find(2, { 'a', 'b', 'c' }, 'b')
  assert_find(3, { 'a', 'b', 'c' }, 'c')
  assert_find(nil, { 'a', 'b', 'c' }, 'd')

  assert_find('a', { a = 'x', b = 'y', c = 'z' }, 'x')
  assert_find('b', { a = 'x', b = 'y', c = 'z' }, 'y')
  assert_find('c', { a = 'x', b = 'y', c = 'z' }, 'z')
  assert_find(nil, { a = 'x', b = 'y', c = 'z' }, 'w')

  assert_find(1, { 30, 20, 10 }, value -> value < 40)
  assert_find(2, { 30, 20, 10 }, value -> value < 30)
  assert_find(3, { 30, 20, 10 }, value -> value < 20)

  assert_find('a', { a = 10 }, value -> value < 20)
  assert_find(nil, { a = 20 }, value -> value < 20)
})

spec('table.keys', () -> {
  local function assert_keys(expected, t) {
    local keys = stdlib.table.keys(t)
    table.sort(expected, any_sort)
    table.sort(keys, any_sort)
    assert.are.same(expected, keys)
  }

  assert_keys({}, {})
  assert_keys({ 1 }, { 'a' })
  assert_keys({ 1, 2 }, { 'a', 'b' })
  assert_keys({ 'a' }, { a = 10 })
  assert_keys({ 'a', 'b' }, { a = 10, b = 20 })
  assert_keys({ 1, 'b' }, { 'a', b = 10 })
})

spec('table.map', () -> {
  assert.are.same({}, stdlib.table.map({}, value -> true))
  assert.are.same({}, stdlib.table.map({ 1, 2, 3 }, value -> nil))

  assert.are.same({ 0, 10, 20 }, stdlib.table.map({ 0, 1, 2 }, value -> 10 * value))
  assert.are.same({ a = 10, b = 20 }, stdlib.table.map({ a = 1, b = 2 }, value -> 10 * value))

  assert.are.same({ a = 10 }, stdlib.table.map({ 1 }, value -> (10 * value, 'a')))
  assert.are.same({ 10 }, stdlib.table.map({ a = 1 }, value -> (10 * value, 1)))
  assert.are.same({ b = 10 }, stdlib.table.map({ a = 10 }, value -> (value, 'b')))
})

spec('table.reduce', () -> {
  assert.are.equal(60, stdlib.table.reduce({ 10, 20, 30 }, 0, (reduction, value) -> reduction + value))
  assert.are.equal(70, stdlib.table.reduce({ 10, 20, 30 }, 10, (reduction, value) -> reduction + value))
  assert.are.equal(60, stdlib.table.reduce({ a = 10, b = 20, c = 30 }, 0, (reduction, value) -> reduction + value))
  assert.are.equal(70, stdlib.table.reduce({ a = 10, b = 20, c = 30 }, 10, (reduction, value) -> reduction + value))
})

spec('table.reverse', () -> {
  local function assert_reverse(expected, t) {
    stdlib.table.reverse(t)
    assert.are.same(expected, t)
  }

  assert_reverse({}, {})
  assert_reverse({ 'a' }, { 'a' })
  assert_reverse({ 'b', 'a' }, { 'a', 'b' })
  assert_reverse({ 'c', 'b', 'a' }, { 'a', 'b', 'c' })
  assert_reverse({ 'c', 'b', 'a', d = true }, { 'a', 'b', 'c', d = true })
})

spec('table.slice', () -> {
  assert.are.same({}, stdlib.table.slice({}))
  assert.are.same({ 1, 2 }, stdlib.table.slice({ 1, 2 }))
  assert.are.same({ 1, 2 }, stdlib.table.slice({ 1, 2, a = 3 }))

  assert.are.same({ 'a', 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 1))
  assert.are.same({ 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 2))
  assert.are.same({ 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 3))

  assert.are.same({ 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, -1))
  assert.are.same({ 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, -2))
  assert.are.same({ 'a', 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, -3))

  assert.are.same({ 'a' }, stdlib.table.slice({ 'a', 'b', 'c' }, 1, 1))
  assert.are.same({ 'a', 'b' }, stdlib.table.slice({ 'a', 'b', 'c' }, 1, 2))
  assert.are.same({ 'b' }, stdlib.table.slice({ 'a', 'b', 'c' }, 2, 2))
  assert.are.same({ 'a', 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 1, 3))

  assert.are.same({ 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 2, -1))
  assert.are.same({ 'a', 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 1, -1))
  assert.are.same({ 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, 3, -1))
  assert.are.same({ 'b', 'c' }, stdlib.table.slice({ 'a', 'b', 'c' }, -2, 3))

  assert.are.same({}, stdlib.table.slice({ 'a', 'b', 'c' }, 4))
})

spec('table.values', () -> {
  local function assert_values(expected, t) {
    local values = stdlib.table.values(t)
    table.sort(expected, any_sort)
    table.sort(values, any_sort)
    assert.are.same(expected, values)
  }

  assert_values({}, {})
  assert_values({ 'a' }, { 'a' })
  assert_values({ 'a', 'b' }, { 'a', 'b' })
  assert_values({ 1 }, { a = 1 })
  assert_values({ 1, 2 }, { a = 1, b = 2 })
  assert_values({ 1, 'a' }, { 'a', b = 1 })
})
